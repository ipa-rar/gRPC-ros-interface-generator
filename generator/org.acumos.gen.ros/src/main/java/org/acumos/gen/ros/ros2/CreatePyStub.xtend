/*****************************************************************************
 * Copyright (c) 2021 CEA LIST.
 * 
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 * 
 *****************************************************************************/
 
package org.acumos.gen.ros.ros2

import com.google.protobuf.DescriptorProtos.DescriptorProto


import static extension org.acumos.gen.ros.TrafoUtils.*
import com.google.protobuf.DescriptorProtos.FileDescriptorProto
import com.google.protobuf.DescriptorProtos.MethodDescriptorProto
import com.google.protobuf.DescriptorProtos.ServiceDescriptorProto

class CreatePyStub {
	
	FileDescriptorProto proto
	
	ServiceDescriptorProto service
	
	new(FileDescriptorProto proto, ServiceDescriptorProto service) {
		this.proto = proto;
		this.service = service;
	}
	
	def createStub(MethodDescriptorProto method) '''
		«var request = proto.getTypeFromName(method.inputType)»
		«var response = proto.getTypeFromName(method.outputType)»
		# Subscribes '«request.name»'
		# Publishes  '«response.name»'
««« TODO always broker_topic or depends on input?»
		import grpc
		import rclpy
		from rclpy.node import Node
		from rclpy.executors import SingleThreadedExecutor
		
		# proto to ROS msg converted messages
		from «proto.name.stripExt»_msgs.msg import «request.name»
		from «proto.name.stripExt»_msgs.msg import «response.name»
		# proto autogenerated messages for payload
		from . import «proto.name.stripExt»_pb2 as pb2
««« Why pb2? depends on proto file?
		# # proto autogenerated messages for setting up communcation channel
		from . import «proto.name.stripExt»_pb2_grpc as pb2_grpc
		PORT = 'simple_server_app:50051'
		
		
		class GrpcClient(Node):
		
		    def __init__(self, 
		                topic_sub='grpc_request', 
		                topic_pub='grpc_response', 
		                req_msg_type=«request.name»,
		                res_msg_type=«response.name»):
		        super().__init__('broker_service_request')
		        """
		        initializes the grpc communciation channel, 
		        subscriber and publisher to/from ROS side
		        """
		        channel = grpc.insecure_channel(PORT)
		        self.stub = pb2_grpc.«service.name»Stub(channel)
		        self.sub = self.create_subscription(
		            req_msg_type,
		            topic_sub,
		            self.grpc_server_request,
		            10
		        )
		        self.pub = self.create_publisher(
		            res_msg_type,
		            topic_pub,
		            10
		        )

		    «method.publishMethod(request, response)»

		    «subscribeMethod»

	'''
	
	def publishMethod(MethodDescriptorProto method, DescriptorProto request, DescriptorProto reply) '''
		def grpc_server_request(self, msg):
		    """
		    This is a callback from the sub and publishes 
		    the subscribed payload directly to the gRPC server.
		    «proto.name.stripExt»_pb2 module is used to publish the subscribed ROS msgs to server
		    """
		    # Send request payload as ROS msg
		    request = pb2.«request.name»(
		        «FOR field : request.flatFields SEPARATOR(',')»
««« TODO: need cast?
		        	«field.name» = msg.«field.name»
		        «ENDFOR»
		    )
		    response = self.stub.«method.name»(request)
		    # Convert the protobuf response payload to ROS msg
		    self.msg = «reply.name»()
		    «FOR field : reply.flatFields SEPARATOR(',')»
		    	self.msg.«field.name» = response.«field.name»
		    «ENDFOR»
		    self.grpc_server_response(self.msg)
	'''
	
	def subscribeMethod() '''
		def grpc_server_response(self, msg):
		    """
		    Publishes the gRPC server response to the ROS side
		    """
		    self.pub.publish(msg)
	'''

	def createMain() '''
		def main(args=None):
		    rclpy.init(args=args)
		    try:
		        grpc_client = GrpcClient()
		        executor = SingleThreadedExecutor()
		        executor.add_node(grpc_client)
		        try:
		            executor.spin()
		        finally:
		            executor.shutdown()
		            grpc_client.destroy_node()
		
		    except KeyboardInterrupt:
		        rclpy.shutdown()


		if __name__ == '__main__':
		    main()
	'''	
}