/*****************************************************************************
 * Copyright (c) 2021 CEA LIST.
 * 
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 * 
 *****************************************************************************/
 
package org.acumos.gen.ros.ros1

import com.google.protobuf.DescriptorProtos.DescriptorProto


import static extension org.acumos.gen.ros.TrafoUtils.*
import com.google.protobuf.DescriptorProtos.FileDescriptorProto
import com.google.protobuf.DescriptorProtos.MethodDescriptorProto
import com.google.protobuf.DescriptorProtos.ServiceDescriptorProto

class CreatePyStub {
	
	FileDescriptorProto proto
	
	ServiceDescriptorProto service
	
	new(FileDescriptorProto proto, ServiceDescriptorProto service) {
		this.proto = proto;
		this.service = service;
	}
	
	def createStub(MethodDescriptorProto method) '''
		«var request = proto.getTypeFromName(method.inputType)»
		«var response = proto.getTypeFromName(method.outputType)»
		# Subscribes '«request.name»'
		# Publishes  '«response.name»'
««« TODO always broker_topic or depends on input?»
		import grpc
		import rospy
		# proto to ROS msg converted messages
		from «proto.name.stripExt»_msgs.msg import «request.name»
		from «proto.name.stripExt»_msgs.msg import «response.name»
		# proto autogenerated messages for payload
		from . import «proto.name.stripExt»_pb2 as pb2
		# proto autogenerated messages for setting up communciation channel
		import «proto.name.stripExt»_pb2_grpc_pb2_grpc as pb2_grpc
		# Communication address:port with the gRPC server
		PORT = 'localhost:50051'
««« Why pb2? depends on proto file?

		class GrpcClient(Node):
		
		    def __init__(self, 
		                topic_sub='grpc_request', 
		                topic_pub='grpc_response', 
		                req_msg_type=«request.name»,
		                res_msg_type=«response.name»):
		        super().__init__('broker_service_request')
		        """
		        initializes the grpc communciation channel, 
		        subscriber and publisher to/from ROS side
		        """
		        channel = grpc.insecure_channel(PORT)
		        self.stub = pb2_grpc.«service.name»Stub(channel)
		        self.sub = rospy.Subscriber(
		            topic_sub,
		            req_msg_type,
		            self.grpc_server_request
		        )
		        self.pub = self.create_publisher(
		            topic_pub,
		            res_msg_type,
		            queue_size = 10
		        )

		    «method.publishMethod(request, response)»

		    «subscribeMethod(request, response)»

	'''
	
	def publishMethod(MethodDescriptorProto method, DescriptorProto request, DescriptorProto response) '''
		def grpc_server_request(self, msg):
		    """
		    This is a callback from the sub and publishes 
		    the subscribed payload directly to the gRPC server.
		    «proto.name.stripExt»_pb2 module is used to publish the subscribed ROS msgs to server
		    """
		    # Send request payload as ROS msg
		    request = pb2.«request.name»(
		        «FOR field : request.flatFields SEPARATOR(',')»
««« TODO: need cast?
		        	«field.name» = msg.«field.name»
		        «ENDFOR»
		    )
		    response = self.stub.«method.name»(request)
		    rospy.loginfo("«FOR i : 0..request.numberOfFields-1 SEPARATOR(', ')»{«i»}«ENDFOR»".format(«FOR field : request.flatFields SEPARATOR(', ')»msg.«field.name»«ENDFOR»))
		    
		    # Convert the protobuf response payload to ROS msg
		    self.msg = «response.name»()
		    «FOR field : response.flatFields»
		    	self.msg.«field.name» = response.«field.name»
		    «ENDFOR»
		    self.grpc_server_response(self.msg)
	'''
	
	def subscribeMethod(DescriptorProto request, DescriptorProto response) '''
		def grpc_server_response(self, msg):
		    """
		    Publishes the gRPC server response to the ROS side
		    """
		    self.pub.publish(msg)
		    rospy.loginfo("«FOR i : 0..response.numberOfFields-1 SEPARATOR(', ')»{«i»}«ENDFOR»".format(«FOR field : response.flatFields SEPARATOR(', ')»msg.«field.name»«ENDFOR»))
	'''

	def createMain() '''
		def main(args=None):
		    rospy.init_node('«service.name»')
		    GrpcClient()
		    while not rospy.is_shutdown():
		        try:
		            rospy.spin()
		        except rospy.ROSInterruptException:
		        rospy.logerr("ROS Interrupt Exception! Just ignore the exception!")


		if __name__ == '__main__':
		    main()
	'''	
}