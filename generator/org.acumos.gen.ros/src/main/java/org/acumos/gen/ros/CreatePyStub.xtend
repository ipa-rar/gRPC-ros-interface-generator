/*****************************************************************************
 * Copyright (c) 2021 CEA LIST.
 * 
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 * 
 *****************************************************************************/
 
 package org.acumos.gen.ros

import com.google.protobuf.DescriptorProtos.DescriptorProto


import static extension org.acumos.gen.ros.TrafoUtils.*
import com.google.protobuf.DescriptorProtos.FileDescriptorProto
import com.google.protobuf.DescriptorProtos.MethodDescriptorProto
import com.google.protobuf.DescriptorProtos.ServiceDescriptorProto

class CreatePyStub {
	
	FileDescriptorProto proto
	
	ServiceDescriptorProto service
	
	new(FileDescriptorProto proto, ServiceDescriptorProto service) {
		this.proto = proto;
		this.service = service;
	}
	
	def createStub(MethodDescriptorProto method) '''
		«var request = proto.getTypeFromName(method.inputType)»
		«var reply = proto.getTypeFromName(method.outputType)»
		# Subscribes '«request.name»'
		# Publishes  '«reply.name»'
««« TODO always broker_topic or depends on input?»
		# to Topic 'broker_topic'
		# 0.1 sec interval publishing
		# QoS is 10 by default
		import grpc
		import rclpy
		from rclpy.node import Node
		from rclpy.executors import SingleThreadedExecutor
		
		# proto to ROS msg converted messages
		from grpc_ros_interface.msg import «request.name»
		from grpc_ros_interface.msg import «reply.name»
		# proto autogenerated messages for payload
		from . import «proto.name.stripExt»_pb2 as pb2
««« Why pb2? depends on proto file?
		# # proto autogenerated messages for setting up communcation channel
		from . import «proto.name.stripExt»_pb2_grpc as pb2_grpc
		PORT = 'simple_server_app:50051'
		
		
		class GrpcClient(Node):
		
		    def __init__(self, 
		                topic_sub='request_topic', 
		                topic_pub='response_topic', 
		                msg_type=«request.name»):
		        super().__init__('broker_service_request')
		        """
		        initializes the grpc communciation channel, 
		        subscriber and publisher to/from ROS side
		        """
		        channel = grpc.insecure_channel(PORT)
		        self.stub = pb2_grpc.«service.name»Stub(channel)
		        self.data_subscriber = self.create_subscription(
		            msg_type,
		            topic_sub,
		            self.publish_to_grpc_«request.name»,
		           10
		        )
		        self.data_publisher = self.create_publisher(
		            BrokerResponse,
		            topic_pub,
		            10
		        )

		    «method.publishMethod(request, reply)»

		    «subscribeMethod»
	'''
	
	def publishMethod(MethodDescriptorProto method, DescriptorProto request, DescriptorProto reply) '''
		def publish_to_grpc_server(self, msg):
		    """
		    This is a callback from the data_subscriber and publishes 
		    the subscribed payload directly to the gRPC server.
		    «proto.name.stripExt»_pb2 module is used to publish the subscribed ROS msgs to server
		    """
		    # Send request payload as ROS msg
		    request = pb2.«request.name»(
		        «FOR fieldKey : request.allFields.keySet»
		        	«FOR field : getFields(request, fieldKey) SEPARATOR(',')»
««« TODO: need cast?
		        		«field.name» = msg.«field.name»
		        	«ENDFOR»
		        «ENDFOR»
		    )
		    response = self.stub.«method.name»(request)
		
		    # Convert the protobuf response payload to ROS msg
		    self.msg = «reply.name»()
			«FOR fieldKey : reply.allFields.keySet»
				«FOR field : getFields(reply, fieldKey)»
				    self.msg.«field.name» = response.«field.name»
				«ENDFOR»
			«ENDFOR»
		    self.subscribe_grpc_«reply.name»(self.msg)
	'''
	
	def subscribeMethod() '''
		def subscribe_grpc_server(self, msg):
		    """
		    Publishes the gRPC server response to the ROS side
		    """
		    self.data_publisher.publish(msg)
	'''

	def createMain(DescriptorProto msgType) '''
		def main(args=None):
		    rclpy.init(args=args)
		    try:
		        grpc_client = GrpcClient()
		        executor = SingleThreadedExecutor()
		        executor.add_node(grpc_client)
		        try:
		            executor.spin()
		        finally:
		            executor.shutdown()
		            grpc_client.destroy_node()
		
		    except KeyboardInterrupt:
		        rclpy.shutdown()
		
		
		if __name__ == '__main__':
		    main()
	'''	
}